# **Binary Trees**

---

#### A tree in which every NODE have

> class Node {
>
> ​	private int data;
>
> ​	private Node left, right;
>
> ​	public Node(int data) {
>
> ​		this.data = data;
>
> ​		this.left = this.right = null;
>
> ​	}
>
> }

- 1 child node
- 2 child node (MAX)
- No child node

> **ROOT -> Parent --> Child**
>
> *------ Internal nodes -------* 			*--- Leaf nodes ---*



## **BST (Binary search tree)**

> We have a **pattern** here aka in a *Binary tree any parent node **can have any number in the left and right child(s) nodes*** BUT *in a BST **all the left child(s) will be less then parent** and **all the right child(s) will be greater than parent***



## Traversals

​		Basically printing the data in the nodes of binary tree in a specific format

> #### Preorder :arrow_right: *root > left > right*
>
> public void preorder(Node root) {
>
> ​	if(root == null) return;
>
> ​	sout(root.data) // **Preorder**
>
> ​	preorder(root.left)
>
> ​	preorder(root.right)
>
> }
>
> #### Inorder :arrow_right: *left > root > right*
>
> public void preorder(Node root) {
>
> ​	if(root == null) return;
>
> ​	preorder(root.left)
>
> ​	sout(root.data) // **Inorder**
>
> ​	preorder(root.right)
>
> }
>
> #### Postorder :arrow_right: *left > right > root*
>
> public void preorder(Node root) {
>
> ​	if(root == null) return;
>
> ​	preorder(root.left)
>
> ​	preorder(root.right)
>
> ​	sout(root.data) // **Postorder**
>
> }



# **Problems**

---

#### Kth largest element in BST

> - Inorder basically prints in sorted order for BST
> - To make it descending print in reverse
> - Keep track of count and return data when count == k;

#### Convert BT to DLL

> - Find Inorder succesor of every node
> - Take a global flag to mark parent for the first time starting
> - Keep updating the node left and parent right while updating parent

#### Height of a Binary tree / (Edges = height - 1)

> - *Recursive leap of faith...*
>   - Find Base case
>   - Deduce relation
>   - generalize
> - If root is null then the height is 0 (Base case)
> - root ki left and right height ka max will give height +1 for root node

#### Is Binary tree balanced

> - A balanced binary tree is basically where **diff of the height of left and right subtree is not more than 1**
> - *Naive -* find height of left and right of *each and every node* and check if Math.abs(left-right) <= 1
> - *Optimal* -  Why to check for every node, while finding the hight if at any given point Math.abs(left-right) > 1 then ofcourse it is not balanced and return -1 / false

#### Print nodes at k distance

> - Post order traversal with keeping track of count increment and decrement accordingly
> - use k itself and keep decrementing and passing to the fun and if it becomes 0 then we are for sure at that distance

#### Print nodes at k distance from any target

> // TODO  - https://www.youtube.com/watch?v=i9ORlEy6EsI

#### Delete a node with a given key in BST

> - *Parent ko pakad k rakhna h*
> - Leaf and iternal node with one child is easy to delete
> - internal node with two child, We take the min value from right and *swap this with current while removing the leaf node*

